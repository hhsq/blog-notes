## **JavaScript系列之继承的实现方式**
首先我们要知道JavaScript是一门面向对象的语言，面向对象编程是用抽象方式创建基于现实世界模型的一种编程模式，使用模块化，封装，继承和多态等技术。
像Java就是听过类实现继承，JavaScript在es6也加入了类，但他只是一个语法糖。下面我们就讲讲JavaScript继承的实现方式。
#### 原型链继承及原型继承
 ```js
function Father() {
    this.name = "name";
    this.other = [1, 2, 3]
}
  
function Son() {}
function Son1() {}

Son.prototype = new Father();
Son1.prototype = new Father();
const son = new Son();
const son1 = new Son();
Son.prototype.constructor = Son;
Son1.prototype.constructor = Son1; // 让其constructor指向自己（因为这种方式实现继承会使其constructor丢失）
son.name = 'newName';
son.other.push(4);
console.log(son.name); // newName
console.log(son1.name); // name
console.log(son.other); // [1, 2, 3, 4]
console.log(son1.other); // [1, 2, 3, 4]
```
* 上述方法存在问题如下：
  - 1.如果其中有引用类型则会被其他实例共享
  - 2.创建实例时无法往Father传递参数

#### 借用构造函数（子类型构造函数的内部调用父构造函数）
 ```js
function Father(name) {
  this.name = name;
  this.other = [1, 2, 3]
}
function Son(name) {
  Father.call(this, name);
}
const son = new Son('son');
const son1 = new Son('son1');
son.other.push(4);
console.log(son.name); // son
console.log(son1.name); // son1
console.log(son.other); // [1, 2, 3, 4]
console.log(son1.other); // [1, 2, 3]
 ```
* 借用构造函数我们就可以解决原型继承的两大问题
   - 引用类型不会共享
   - 可以向父构造函数（Father）传递参数
* 导致的问题
   - 方法都在构造函数中定义，函数无法复用
 
#### 组合继承（双剑合璧）
```js
function Father(name) {
  this.name = name;
}

Father.prototype.getName = function () {
  console.log(this.name)
};

function Son(name) {
  Father.call(this, name); // 继承父类属性
}

Son.prototype = new Father(); // 继承父类方法
Son.prototype.constructor = Son; // 重写其constructor
```
此方法好处在于取长补短，用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承。  
而组合继承最大的问题则在于他会调用两次父构造函数，而这会导致原型中属性重复

#### 原型继承
```js
function prototypeExtend(o) {
  function F() {}
  F.prototype = o;
  return new F();
}
```
原型继承 => 将传入的对象作为创建的对象的原型（这个方式可以用Object.create()取代）,确定和原型式继承差不多

参考1:[new操作符做了什么](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)